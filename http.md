1. HTTP/0.9 – 单行协议
请求: GET /mypage.html
响应: <HTML>这是一个非常简单的HTML页面</HTML>

HTTP/1.0 – 构建可扩展性
协议版本信息现在会随着每个请求发送（HTTP/1.0被追加到了GET行）。
状态码会在响应开始时发送，使浏览器能了解请求执行成功或失败，并相应调整行为（如更新或使用本地缓存）。
引入了HTTP头的概念，无论是对于请求还是响应，允许传输元数据，使协议变得非常灵活，更具扩展性。
在新HTTP头的帮助下，具备了传输除纯文本HTML文件以外其他类型文档的能力（感谢Content-Type头）。


HTTP/1.1 消除了大量歧义内容并引入了多项改进：

连接可以复用，节省了多次打开TCP连接加载网页文档资源的时间。
增加管线化技术，允许在第一个应答被完全发送之前就发送第二个请求，以降低通信延迟。
支持响应分块。
引入额外的缓存控制机制  cache-control。
引入内容协商机制，包括语言，编码，类型等，并允许客户端和服务器之间约定以最合适的内容进行交换。
感谢Host头，能够使不同域名配置在同一个IP地址的服务器上。


HTTP/2在HTTP/1.1有几处基本的不同:

HTTP/2是二进制协议而不是文本协议。不再可读，也不可无障碍的手动创建，改善的优化技术现在可被实施。
这是一个复用协议。
并行的请求能在同一个链接中处理，移除了HTTP/1.x中顺序和阻塞的约束。
压缩了headers。因为headers在一系列请求中常常是相似的，其移除了重复和传输重复数据的成本。
其允许服务器在客户端缓存中填充数据，通过一个叫服务器推送的机制来提前请求。

2. http headers

General headers: 同时适用于请求和响应消息，但与最终消息主体中传输的数据无关的消息头。[Date、Cache-Control 或 Connection]
Request headers: 包含更多有关要获取的资源或客户端本身信息的消息头。[Accept、Accept-*、 If-*]
Response headers: 包含有关响应的补充信息，如其位置或服务器本身（名称和版本等）的消息头。[Age, Location 和 Server都属于响应头]
Entity headers: 包含有关实体主体的更多信息，比如主体长(Content-Length)度或其MIME类型。

3. HTTP 请求方式
GET: GET方法请求一个指定资源的表示形式，使用GET的请求应该只被用于获取数据
HEAD:HEAD方法请求一个与GET请求的响应相同的响应，但没有响应体。可返回标头获得响应首部
POST:POST方法用于将实体提交到指定的资源，通常导致在服务器上的状态变化或副作用。
PUT:PUT方法用请求有效载荷替换目标资源的所有当前表示(上传或者替换资源)
PUT 和 POST 之间的区别在于 PUT 是幂等的：连续调用一次或多次具有相同的效果（即没有副作用），而连续相同的 POST 请求可能具有额外的效果，类似于多次下订单。
DELETE:删除指定资源
CONNECT:CONNECT方法建立一个到由目标资源标识的服务器的隧道。
OPTIONS:OPTIONS方法用于描述目标资源的通信选项。用于循问服务器支持的方法或跨域发起预检请求查看支持的header以及方法

4.HTTP 响应代码
响应分为五类：信息响应(100–199)，成功响应(200–299)，重定向(300–399)，客户端错误(400–499)和服务器错误 (500–599)

信息响应
100. 临时响应表明，迄今为止的所有内容都是可行的，客户端应该继续请求，如果已经完成，则忽略它。
101. 响应客户端的 Upgrade (en-US) 标头发送的，并且指示服务器也正在切换的协议
102. 表示服务器已收到并正在处理该请求，但没有响应可用。
103. 主要用于与Link 链接头一起使用，以允许用户代理在服务器仍在准备响应时开始预加载资源。

成功响应
200. OK 请求成功 
GET：资源已被提取并在消息正文中传输。
HEAD：实体标头位于消息正文中。
POST：描述动作结果的资源在消息体中传输。
TRACE：消息正文包含服务器收到的请求消息

201. Created 请求已成功，并因此创建了一个新的资源。这通常是在POST请求，或是某些PUT请求之后返回的响应。

202. Accepted 请求已经接收到，但还未响应，没有结果。意味着不会有一个异步的响应去表明当前请求的结果，预期另外的进程和服务去处理请求，或者批处理。

203. Non-Authoritative Information 服务器已成功处理了请求，但返回的实体头部元信息不是在原始服务器上有效的确定集合，而是来自本地或者第三方的拷贝。当前的信息可能是原始版本的子集或者超集。例如，包含资源的元数据可能导致原始服务器知道元信息的超集。使用此状态码不是必须的，而且只有在响应不使用此状态码便会返回200 OK的情况下才是合适的。

204. No Content 服务器成功处理了请求，但不需要返回任何实体内容(No Content)，并且希望返回更新了的元信息。响应可能通过实体头部的形式，返回新的或更新后的元信息。如果存在这些头部信息，则应当与所请求的变量相呼应。如果客户端是浏览器的话，那么用户浏览器应保留发送了该请求的页面，而不产生任何文档视图上的变化，即使按照规范新的或更新后的元信息应当被应用到用户浏览器活动视图中的文档。由于204响应被禁止包含任何消息体，因此它始终以消息头后的第一个空行结尾。
使用惯例是，在 PUT 请求中进行资源更新，但是不需要改变当前展示给用户的页面，那么返回 204 No Content。如果创建了资源，则返回 201 Created 。如果应将页面更改为新更新的页面，则应改用 200 。

205. Reset Content 服务器成功处理了请求，且没有返回任何内容。但是与204响应不同，返回此状态码的响应要求请求者重置文档视图。该响应主要是被用于接受用户输入后，立即重置表单，以便用户能够轻松地开始另一次输入。与204响应一样，该响应也被禁止包含任何消息体，且以消息头后的第一个空行结束。

206. Partial Content 服务器已经成功处理了部分 GET 请求。类似于 FlashGet 或者迅雷这类的 HTTP 下载工具都是使用此类响应实现断点续传或者将一个大文档分解为多个下载段同时下载。该请求必须包含 Range 头信息来指示客户端希望得到的内容范围，并且可能包含 If-Range 来作为请求条件。

207. Multi-Status WebDAV(RFC 2518)扩展的状态码，代表之后的消息体将是一个XML消息，并且可能依照之前子请求数量的不同，包含一系列独立的响应代码。

208. Already Reported  在 DAV 里面使用: propstat 响应元素以避免重复枚举多个绑定的内部成员到同一个集合。

226. IM Used服务器已经完成了对资源的 GET 请求，并且响应是对当前实例应用的一个或多个实例操作结果的表示。 


重定向
300. Multiple Choice 被请求的资源有一系列可供选择的回馈信息，每个都有自己特定的地址和浏览器驱动的商议信息。用户或浏览器能够自行选择一个首选的地址进行重定向。(不常用)

301. Moved Permanently 被请求的资源已永久移动到新位置，并且将来任何对此资源的引用都应该使用本响应返回的若干个 URI 之一。如果可能，拥有链接编辑功能的客户端应当自动把请求的地址修改为从服务器反馈回来的地址。除非额外指定，否则这个响应也是可缓存的。
请求的资源已经被移动到了由 Location 头部指定的url上，是固定的不会再改变。

302. Found 请求的资源现在临时从不同的 URI 响应请求。由于这样的重定向是临时的，客户端应当继续向原有地址发送以后的请求。只有在Cache-Control或Expires中进行了指定的情况下，这个响应才是可缓存的。
推荐仅在响应 GET 或 HEAD 方法时采用 302 状态码，而在其他时候使用 307 Temporary Redirect 来替代

303. See Other 对应当前请求的响应可以在另一个 URI 上被找到，而且客户端应当采用 GET 的方式访问那个资源。这个方法的存在主要是为了允许由脚本激活的POST请求输出重定向到一个新的资源。

304. Not Modified 未改变 如果客户端发送了一个带条件的 GET 请求且该请求已被允许，而文档的内容（自上次访问以来或者根据请求的条件）并没有改变，则服务器应当返回这个状态码。304 响应禁止包含消息体，因此始终以消息头后的第一个空行结尾。

305. Use Proxy 被请求的资源必须通过指定的代理才能被访问。Location 域中将给出指定的代理所在的 URI 信息，接收者需要重复发送一个单独的请求，通过这个代理才能访问相应资源。只有原始服务器才能建立305响应。
306. unused 在最新版的规范中，306 状态码已经不再被使用。

307. Temporary Redirect 请求的资源现在临时从不同的URI 响应请求。由于这样的重定向是临时的，客户端应当继续向原有地址发送以后的请求。只有在Cache-Control或Expires中进行了指定的情况下，这个响应才是可缓存的。 
状态码 307 与 302 之间的唯一区别在于，当发送重定向请求的时候，307 状态码可以确保请求方法和消息主体不会发生变化。如果使用 302 响应状态码，一些旧客户端会错误地将请求方法转换为 GET：也就是说，在 Web 中，如果使用了 GET 以外的请求方法，且返回了 302 状态码，则重定向后的请求方法是不可预测的；但如果使用 307 状态码，之后的请求方法就是可预测的。对于 GET 请求来说，两种情况没有区别。

308. Permanent Redirect 这意味着资源现在永久位于由 Location: HTTP Response 标头指定的另一个 URI。 这与 301 Moved Permanently HTTP 响应代码具有相同的语义，但用户代理不能更改所使用的 HTTP 方法：如果在第一个请求中使用 POST，则必须在第二个请求中使用 POST。
在重定向过程中，请求方法和消息主体不会发生改变，然而在返回 301 状态码的情况下，请求方法有时候会被客户端错误地修改为 GET 方法。

客户端响应
400. Bad Request 1、语义有误，当前请求无法被服务器理解。除非进行修改，否则客户端不应该重复提交这个请求。2、请求参数有误。

401. Unauthorized 由于缺乏目标资源要求的身份验证凭证，发送的请求未得到满足。

402. Payment Required 此响应码保留以便将来使用，创造此响应码的最初目的是用于数字支付系统，然而现在并未使用。

403. Forbidden 服务器端有能力处理该请求，但是拒绝授权访问。

404. Not Found 请求失败，请求所希望得到的资源未被在服务器上发现

405. Method Not Allowed 请求行中指定的请求方法不能被用于请求相应的资源。该响应必须返回一个Allow 头信息用以表示出当前资源能够接受的请求方法的列表。

406. Not Acceptable 服务器端无法提供与  Accept-Charset 以及 Accept-Language 消息头指定的值相匹配的响应。

407. Proxy Authentication Required 与401响应类似，只不过客户端必须在代理服务器上进行身份验证。代理服务器必须返回一个 Proxy-Authenticate 用以进行身份询问。客户端可以返回一个 Proxy-Authorization 信息头用以验证。

408. Request Timeout 请求超时。客户端没有在服务器预备等待的时间内完成一个请求的发送。客户端可以随时再次提交这一请求而无需进行任何更改。

409. Conflict 由于和被请求的资源的当前状态之间存在冲突，请求无法完成。这个代码只允许用在这样的情况下才能被使用：用户被认为能够解决冲突，并且会重新提交新的请求。该响应应当包含足够的信息以便用户发现冲突的源头

410. Gone 被请求的资源在服务器上已经不再可用，而且没有任何已知的转发地址。这样的状况应当被认为是永久性的。如果可能，拥有链接编辑功能的客户端应当在获得用户许可后删除所有指向这个地址的引用。如果服务器不知道或者无法确定这个状况是否是永久的，那么就应该使用 404 状态码。除非额外说明，否则这个响应是可缓存的。

411. Length Required 服务器拒绝在没有定义 Content-Length 头的情况下接受请求。在添加了表明请求消息体长度的有效 Content-Length 头之后，客户端可以再次提交该请求。

412. Precondition Failed 服务器在验证在请求的头字段中给出先决条件时，没能满足其中的一个或多个。这个状态码允许客户端在获取资源时在请求的元信息（请求头字段数据）中设置先决条件，以此避免该请求方法被应用到其希望的内容以外的资源上。

413. Payload Too Large 服务器拒绝处理当前请求，因为该请求提交的实体数据大小超过了服务器愿意或者能够处理的范围。此种情况下，服务器可以关闭连接以免客户端继续发送此请求。如果这个状况是临时的，服务器应当返回一个 Retry-After 的响应头，以告知客户端可以在多少时间以后重新尝试。

414. URI Too Long 请求的URI 长度超过了服务器能够解释的长度，因此服务器拒绝对该请求提供服务。这比较少见，通常的情况包括：本应使用POST方法的表单提交变成了GET方法，导致查询字符串（Query String）过长。

415. Unsupported Media Type 对于当前请求的方法和所请求的资源，请求中提交的实体并不是服务器中所支持的格式，因此请求被拒绝。

416. Range Not Satisfiable 如果请求中包含了 Range 请求头，并且 Range 中指定的任何数据范围都与当前资源的可用范围不重合，同时请求中又没有定义 If-Range 请求头，那么服务器就应当返回416状态码。

417. Expectation Failed 此响应代码意味着服务器无法满足 Expect 请求标头字段指示的期望值。

418. I'm a teapot 客户端错误响应代码表示服务器拒绝冲泡咖啡，因为它是个茶壶。

421. Misdirected Request 该请求针对的是无法产生响应的服务器。 这可以由服务器发送，该服务器未配置为针对包含在请求 URI 中的方案和权限的组合产生响应。

422. Unprocessable Entity 请求格式良好，但由于语义错误而无法遵循。

423. Locked 正在访问的资源被锁定。

424. Failed Dependency 由于先前的请求失败，所以此次请求失败。

425. Too Early 服务器不愿意冒着风险去处理可能重播的请求。

426. Upgrade Required 服务器拒绝使用当前协议执行请求，但可能在客户机升级到其他协议后愿意这样做。 服务器在 426 响应中发送 Upgrade (en-US) 头以指示所需的协议。

428. Precondition Required 原始服务器要求该请求是有条件的。 旨在防止“丢失更新”问题，即客户端获取资源状态，修改该状态并将其返回服务器，同时第三方修改服务器上的状态，从而导致冲突。

429. Too Many Requests 用户在给定的时间内发送了太多请求（“限制请求速率”）。

431. Request Header Fields Too Large 服务器不愿意处理请求，因为它的 请求头字段太大（ Request Header Fields Too Large）。 请求可以在减小请求头字段的大小后重新提交。

451. Unavailable For Legal Reasons 用户请求非法资源，例如：由政府审查的网页。

服务端响应
500. Internal Server Error 服务器遇到了不知道如何处理的情况。

501.  Not Implemented 此请求方法不被服务器支持且无法被处理。只有GET和HEAD是要求服务器支持的，它们必定不会返回此错误代码。

502. Bad Gateway 此错误响应表明服务器作为网关需要得到一个处理这个请求的响应，但是得到一个错误的响应。

503. Service Unavailable 服务器没有准备好处理请求。 常见原因是服务器因维护或重载而停机。

504. Gateway Timeout 当服务器作为网关，不能及时得到响应时返回此错误代码。

505. HTTP Version Not Supported 服务器不支持请求中所使用的HTTP协议版本。

506. Variant Also Negotiates 服务器有一个内部配置错误：对请求的透明内容协商导致循环引用。

507. Insufficient Storage 服务器有内部配置错误：所选的变体资源被配置为参与透明内容协商本身，因此不是协商过程中的适当端点

508. Loop Detected 服务器在处理请求时检测到无限循环。

510. Not Extended 客户端需要对请求进一步扩展，服务器才能实现它。服务器会回复客户端发出扩展请求所需的所有信息。

511. Network Authentication Required 状态码指示客户端需要进行身份验证才能获得网络访问权限。


2. promise
定义: Promise，简单说就是一个容器，里面保存着某个未来才会结束的事件（通常是一个异步操作）的结果。
特点 状态不受外界影响、一旦状态改变,就不会再变

基本用法
const promise = new Promise(function(resolve, reject) {
  // ... some code

  if (/* 异步操作成功 */){
    resolve(value);
  } else {
    reject(error);
  }
});
resolve函数的作用是，将Promise对象的状态从“未完成”变为“成功”（即从 pending 变为 resolved），在异步操作成功时调用，并将异步操作的结果，作为参数传递出去；reject函数的作用是，将Promise对象的状态从“未完成”变为“失败”（即从 pending 变为 rejected），在异步操作失败时调用，并将异步操作报出的错误，作为参数传递出去。

说明: 执行promise的时候,不涉及到状态更改的大多数是同步语句，除非事件循环里的一些方法 如上示例...some code 会同步输出
new Promise((resolve, reject) => {
  resolve(1);
  console.log(2);
}).then(r => {
  console.log(r);
});
// 2
// 1
仍会同步输出 2，1因为resolve(1)被放在事件循环队列里执行，不想这个效果可以直接return resolve(1)


api

Promise.prototype.then()
注意:then方法返回的是一个新的Promise实例（注意，不是原来那个Promise实例）
参数: 方法的第一个参数是resolved状态的回调函数，第二个参数是rejected状态的回调函数，它们都是可选的

Promise.prototype.catch()
Promise.prototype.catch()方法是.then(null, rejection)或.then(undefined, rejection)的别名，用于指定发生错误时的回调函数。
注意: Promise 对象的错误具有“冒泡”性质，会一直向后传递，直到被捕获为止。也就是说，错误总是会被下一个catch语句捕获。

Promise.prototype.finally() finally方法总是会返回原来的值。
finally()方法用于指定不管 Promise 对象最后状态如何，都会执行的操作

// resolve 的值是 undefined
Promise.resolve(2).then(() => {}, () => {})
// resolve 的值是 2
Promise.resolve(2).finally(() => {})

Promise.all()
参数: 接受一个数组作为参数,都是promise实例,如果不是会把参数转为promise实例
将多个 Promise 实例，包装成一个新的 Promise 实例
（1）只有p1、p2、p3的状态都变成fulfilled，p的状态才会变成fulfilled，此时p1、p2、p3的返回值组成一个数组，传递给p的回调函数。

（2）只要p1、p2、p3之中有一个被rejected，p的状态就变成rejected，此时第一个被reject的实例的返回值，会传递给p的回调函数。

注意: 如果作为参数的 Promise 实例，自己定义了catch方法，那么它一旦被rejected，并不会触发Promise.all()的catch方法,相反会调用Promise.then方法

Promise.race() 
参数: 接受一个数组作为参数,都是promise实例,如果不是会把参数转为promise实例
有一个实例率先改变状态，p的状态就跟着改变。那个率先改变的 Promise 实例的返回值，就传递给p的回调函数。

Promise.allSettled()
参数: 接受一个数组作为参数,都是promise实例,如果不是会把参数转为promise实例
用来确定一组异步操作是否都结束了（不管成功或失败）。所以，它的名字叫做”Settled“，包含了”fulfilled“和”rejected“两种情况。
返回；状态只可能变成fulfilled。它的回调函数接收到的参数是数组results。

Promise.any() 
参数: 接受一个数组作为参数,都是promise实例,如果不是会把参数转为promise实例
只要参数实例有一个变成fulfilled状态，包装实例就会变成fulfilled状态；如果所有参数实例都变成rejected状态，包装实例就会变成rejected状态。


3. osi七层或者五层模型

应用层(七层还增加 表示层以及会话层)

dns域名系统(将人类可读域名转换机器可读ip地址)

首先会在浏览器的缓存中查找对应的IP地址，如果查找到直接返回，若找不到继续下一步
将请求发送给本地DNS服务器，在本地域名服务器缓存中查询，如果查找到，就直接将查找结果返回，若找不到继续下一步
本地DNS服务器向根域名服务器发送请求，根域名服务器会返回一个所查询域的顶级域名服务器地址
本地DNS服务器向顶级域名服务器发送请求，接受请求的服务器查询自己的缓存，如果有记录，就返回查询结果，如果没有就返回相关的下一级的权威域名服务器的地址
本地DNS服务器向权威域名服务器发送请求，域名服务器返回对应的结果
本地DNS服务器将返回结果保存在缓存中，便于下次使用
本地DNS服务器将返回结果返回给浏览器

传输层

tcp

udp: 用户数据报协议
特点
1) 面向无连接,不需要是三次握手建立连接,只是数据的搬运工
2) 有单播、多播、广播的功能
3) UDP是面向报文的 发送方的UDP对应用程序交下来的报文，在添加首部后就向下交付IP层。UDP对应用层交下来的报文，既不合并，也不拆分，而是保留这些报文的边界
4) 不可靠性 体现在无连接以及弱网环境下没有拥塞控制,以恒定数据发送，会出现丢包

tcp: 传输控制协议
1) 面向连接 发送数据前两端建立连接(三次握手)
2) 仅支持单播传输 
3) 面向字节流
4) 可靠传输

拥塞控制机制  网络的拥堵情况相关联
(1)慢启动
在开始发送的时候设置cwnd = 1（cwnd指的是拥塞窗口:一次性连续发送多少个数据包）
思路：开始的时候不要发送大量数据，而是先测试一下网络的拥塞程度，由小到大增加拥塞窗口的大小。
为了防止cwnd增长过大引起网络拥塞，设置一个慢开始门限(ssthresh 状态变量)
当cnwd < ssthresh，使用慢开始算法(指数增加)
当cnwd = ssthresh，既可使用慢开始算法，也可以使用拥塞避免算法
当cnwd > ssthresh，使用拥塞避免算法
(2)拥塞避免
拥塞避免未必能够完全避免拥塞，是说在拥塞避免阶段将拥塞窗口控制为按线性增长，使网络不容易出现阻塞。
思路： 让拥塞窗口cwnd缓慢的增大，即每经过一个返回时间RTT就把发送方的拥塞控制窗口加一
(3)快速重传
快重传要求接收方在收到一个失序的报文段后就立即发出重复确认(为的是使发送方及早知道有报文段没有到达对方)。快重传算法规定，发送方只要连续收到三个重复确认就立即重传对方尚未收到的报文段，而不必继续等待设置的重传计时器时间到期。
由于不需要等待设置的重传计时器到期，能尽早重传未被确认的报文段，能提高整个网络的吞吐量
(4)快速恢复
当发送方连续收到三个重复确认时，就执行“乘法减小”算法，把ssthresh门限减半。但是接下去并不执行慢开始算法。
考虑到如果网络出现拥塞的话就不会收到好几个重复的确认，所以发送方现在认为网络可能没有出现拥塞。所以此时不执行慢开始算法，而是将cwnd设置为ssthresh的大小，然后执行拥塞避免算法

流量控制机制  接收方的缓存状态相关联
一般来说，流量控制就是为了让发送方发送数据的速度不要太快，要让接收方来得及接收。
TCP采用大小可变的滑动窗口(rwnd)进行流量控制，窗口大小的单位是字节。这里说的窗口大小其实就是每次传输几个数据。
当一个连接建立时，连接的每一端分配一个缓冲区来保存输入的数据，并将缓冲区的大小发送给另一端。
当数据到达时，接收方发送确认，其中包含了自己剩余的缓冲区大小。（剩余的缓冲区空间的大小被称为窗口，指出窗口大小的通知称为窗口通告 。接收方在发送的每一确认中都含有一个窗口通告。）
如果接收方应用程序读数据的速度能够与数据到达的速度一样快，接收方将在每一确认中发送一个正的窗口通告。
如果发送方操作的速度快于接收方，接收到的数据最终将充满接收方的缓冲区，导致接收方通告一个零窗口 。发送方收到一个零窗口通告时，必须停止发送，直到接收方重新通告一个正的窗口。



网络层

数据链路层(数据单元是帧)

数据链路层的三个基本问题：封装成帧，透明传输，差错检测
适配器，转发器，集线器，网桥，以太网交换机的作用以及适用场合

物理层(主要做的事情就是 透明地传送比特流)


4. 浏览器缓存
<1>
强缓存 ：Cache-Control/Expires: 浏览器判断缓存是否过期，未过期时，直接使用强缓存，Cache-Control的 max-age 优先级高于 Expires

<2>
协商缓存 :缓存已经过期时
唯一标识方案: Etag(response 携带) & If-None-Match(request携带，上一次返回的 Etag): 服务器判断资源是否被修改
最后一次修改时间: Last-Modified(response) & If-Modified-Since (request，上一次返回的Last-Modified)
如果一致，则直接返回 304 通知浏览器使用缓存;如不一致，则服务端返回新的资源
Etag 的优先级高于 Last-Modified
Last-Modified 缺点：
周期性修改，但内容未变时，会导致缓存失效
最小粒度只到 s， s 以内的改动无法检测到

5. udp 和 tcp 效率
UDP报头，大小为8字节，TCP为固定头20字节，以及选项最多可达40字节
1.TCP为了可靠性保证，增加了3次握手4次挥手，复杂的拥塞控制，以及流量控制，让网络传输的延迟进一步增加。
2.采用TCP，一旦发生丢包，TCP会将后续的包缓存起来，等前面的包重传并接收到后再继续发送，延时会越来越大，基于UDP对实时性要求较为严格的情况下，采用自定义重传机制，有包就发，能够把丢包产生的延迟降到最低，尽量减少网络延迟。
3.基于滑动窗口，接收方因为需要对保证顺序，因此前面的包没到，不会继续去处理后续的包。
4.TCP头部的大小，进一步增加了，传输的数据量。

6. ip地址分类
IP地址根据网络号和主机号来分，分为A、B、C三类及特殊地址D、E。    全0和全1的都保留不用。

0+7位网络位+24位主机位
A类：(1.0.0.0-126.0.0.0)（默认子网掩码：255.0.0.0或 0xFF000000）第一个字节为网络号，后三个字节为主机号。该类IP地址的最前面为“0”，所以地址的网络号取值于1~126之间。一般用于大型网络。
127.0.0.1 一般用于自己本地ip

10+14网络位+16位主机位
B类：(128.0.0.0-191.255.0.0)（默认子网掩码：255.255.0.0或0xFFFF0000）前两个字节为网络号，后两个字节为主机号。该类IP地址的最前面为“10”，所以地址的网络号取值于128~191之间。一般用于中等规模网络。

110+21位网络位+8位主机位
C类：(192.0.0.0-223.255.255.0)（子网掩码：255.255.255.0或 0xFFFFFF00）前三个字节为网络号，最后一个字节为主机号。该类IP地址的最前面为“110”，所以地址的网络号取值于192~223之间。一般用于小型网络。

1110+28位多播组号
D类：是多播地址。该类IP地址的最前面为“1110”，所以地址的网络号取值于224~239之间。一般用于多路广播用户[1]  。

E类：是保留地址。该类IP地址的最前面为“1111”，所以地址的网络号取值于240~255之间。

7.子网掩码的作用
解决lP地址分配而产生的虚拟lP技术，通过子网掩码将A、B、C三类地址划分为若干子网，从而显著提高了IP地址的分配效率，有效解决了IP地址资源紧张的局面

可变长度的网络地址分配方式相比以前主类网络划分方式更加灵活，在有限的网址资源的情况下，提高网络地址的利用率，减少网络地址的浪费。而灵活的代价就是：网络地址可以改变长度，没有规律可循了，只能靠子网掩码来划分了，所以这就是子网掩码的用途：区分网络地址和主机地址。
